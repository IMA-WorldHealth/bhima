// reports_proposed/data/bilan.js
// Collects and aggregates data for the enterprise bilan

var q       = require('q');
var db      = require('../../../lib/db');
var numeral = require('numeral');

var formatDollar = '$0,0.00', variationExploitationDate = new Date(), accountList = [],
    subAccounts = [], finalList = [], previousExploitations = [],
    currentExploitations = [], previousSubAccounts = [],
    INCOME_EXPENSE_ACCOUNT_ID = 1, TITLE_ACCOUNT_ID = 3, BALANCE_ACCOUNT_ID = 2 ;

// expose the http route
exports.compile = function (options) {
  'use strict';
  var i18VariationExploitation = options.language == 'fr' ? require('../lang/fr.json').VARIATION_EXPLOITATION : require('../lang/en.json').VARIATION_EXPLOITATION;
  var deferred = q.defer(), context = {}, infos = {}, ROOT_ACCOUNT_ID = 0;

  context.i18n = i18VariationExploitation;
  context.options = options;

  var sql =
    'SELECT account.id, account.account_number, account.account_txt, account.parent, account.is_charge, account.account_type_id, (CASE WHEN account.is_charge = 1 THEN SUM(period_total.debit - period_total.credit) ELSE SUM(period_total.credit - period_total.debit) END) AS balance ' +
    'FROM account LEFT JOIN period_total on account.id = period_total.account_id WHERE account.is_ohada = 1 AND account.account_type_id in (?,?) AND (period_total.fiscal_year_id in (?) OR ISNULL(period_total.fiscal_year_id)) ' +
    'AND account.id NOT IN (SELECT account.id FROM account WHERE account.account_type_id = ?) GROUP BY account.id';

  db.exec(sql, [INCOME_EXPENSE_ACCOUNT_ID, TITLE_ACCOUNT_ID, options.fy, BALANCE_ACCOUNT_ID])
  .then(function (ce) {
    currentExploitations = ce || [];
    return db.exec(sql, [INCOME_EXPENSE_ACCOUNT_ID, TITLE_ACCOUNT_ID, options.pfy, BALANCE_ACCOUNT_ID]);
  })
  .then(function (pe) {
    previousExploitations = pe || [];
    context.data = process(currentExploitations, previousExploitations).sort(function (a, b) { return a.account_number - b.account_number;});
    deferred.resolve(context);
  })
  .catch(deferred.reject)
  .done();
  return deferred.promise;
};

function process (currents, previous) {
  currentSubAccounts = getSubAccountsOnly(currents);
  previousSubAccounts = getSubAccountsOnly(previous);

  currentSubAccounts.forEach(function (item) {
    var parent = getParentAccount(item.parent, currents);
    var result = getAllChild(parent.id);
    parent.children = result.children;
    parent.percent = result.percent;
    parent.balancePrevious = result.balance_previous;
    parent.viewBalancePrevious = getNumeralFormat(parent.balancePrevious);
    parent.balanceCurrent = result.balance_curent;
    parent.viewBalanceCurrent = getNumeralFormat(parent.balanceCurrent);
    parent.variationValue = getNumeralFormat(parent.balanceCurrent - parent.balancePrevious);
    finalList.push(parent);
  });

  previousSubAccounts.forEach(function (item) {
    var parent = getParentAccount(item.parent, currents);
    var result = getAllChild(parent.id);
    parent.children = result.children;
    parent.percent = result.percent;
    parent.balancePrevious = result.balance_previous;
    parent.viewBalancePrevious = getNumeralFormat(parent.balancePrevious);
    parent.balanceCurrent = result.balance_curent;
    parent.viewBalanceCurrent = getNumeralFormat(parent.balanceCurrent);
    parent.variationValue = getNumeralFormat(parent.balanceCurrent - parent.balancePrevious);
    finalList.push(parent);
  });

  return finalList;
}

function getParentAccount(parentId, accounts) {
  var found = false, i = accounts.length - 1;

  while(!found && i--) {
    found = (accounts[i].id === parentId);
  }

  return found ? accounts[i] : null;
}

function getSubAccountsOnly (list) {
  return list.filter(function (item) {
    return item.account_type_id === 1;
  });
}

/*
*Nane : getAllChild
*Params : parentId (the id of the parent account)
*Task : get all child of the id account sent as parameter, get there balance. the children are looked at the currentSubAccount and PreviousSubAccount array
*return : Array of found account child.
*/

function getAllChild (parentId) {
  var founds = [], cTotalDebit = 0,
      cTotalCredit = 0, cTotalBalance = 0,
      pTotalDebit = 0, pTotalCredit = 0, pTotalBalance = 0, inds_c = [], inds_p = [];

  for (var i = currentSubAccounts.length - 1; i >= 0; i--) {
    if (currentSubAccounts[i].parent === parentId) {
      currentSubAccounts[i].balance = currentSubAccounts[i].balance || 0;
      currentSubAccounts[i].viewBalance = getNumeralFormat(currentSubAccounts[i].balance); //parsing the value for the view

      currentSubAccounts[i].previousBalance = getPreviousState(currentSubAccounts[i].id).balance; //getting the balance for the previous fiscal year
      currentSubAccounts[i].viewPreviousBalance = getNumeralFormat(currentSubAccounts[i].previousBalance);

      currentSubAccounts[i].percent = getPercent(currentSubAccounts[i].balance - currentSubAccounts[i].previousBalance, currentSubAccounts[i].previousBalance); //getting variation percent of the account
      currentSubAccounts[i].variationValue = getNumeralFormat(currentSubAccounts[i].balance - currentSubAccounts[i].previousBalance);

      founds.push(currentSubAccounts[i]);

      cTotalBalance += currentSubAccounts[i].balance || 0;
      pTotalBalance += currentSubAccounts[i].previousBalance || 0;
      inds_c.push(i); //storing the founded index
    }
  }

  //looking also in the previous fy

  for (var i = previousSubAccounts.length - 1; i >= 0; i--) {
    if (previousSubAccounts[i].parent === parentId) {
      previousSubAccounts[i].previousBalance = previousSubAccounts[i].balance || 0;
      previousSubAccounts[i].viewPreviousBalance = getNumeralFormat(previousSubAccounts[i].balance);

      previousSubAccounts[i].balance = 0;
      previousSubAccounts[i].viewBalance = getNumeralFormat(previousSubAccounts[i].balance);

      previousSubAccounts[i].percent = getPercent(previousSubAccounts[i].balance - previousSubAccounts[i].previousBalance, previousSubAccounts[i].previousBalance);
      previousSubAccounts[i].variationValue = getNumeralFormat(previousSubAccounts[i].balance - previousSubAccounts[i].previousBalance);

      founds.push(previousSubAccounts[i]);
      pTotalBalance += previousSubAccounts[i].previousBalance || 0;
      inds_p.push(i);
    }
  }

  //removing all found account to make the array short.
  inds_c.forEach(function (item) {
    if (item >= 0) { currentSubAccounts.splice(item, 1); }
  });

  inds_p.forEach(function (item) {
    if (item >= 0) { previousSubAccounts.splice(item, 1); }
  });

  return {
    children : founds,
    balance_curent : cTotalBalance,
    balance_previous : pTotalBalance,
    percent : getPercent(cTotalBalance - pTotalBalance, pTotalBalance)
  };
}

function getPreviousState (id) {
  var previous = {}, ind = -1;

  for (var i = previousSubAccounts.length - 1; i >= 0; i--) {
    if (previousSubAccounts[i].id == id) {
      previous.balance = previousSubAccounts[i].balance || 0;
      ind = i;
      break;
    }
  }
  if (ind >= 0) {previousSubAccounts.splice(ind, 1);} else{previous.balance = 0;}
  return previous;
}

function getNumeralFormat (nb) {
  return numeral(nb || 0).format(formatDollar);
}

//calculate the percent of x in y

function getPercent(x, y) {
  return (y === 0) ? 100 : (x / y) * 100;
}
